# 自定义持久层框架

## 说在前面
- **本章相关代码及笔记地址：**[**飞机票🚀**](https://github.com/EayonLee/JavaGod/tree/main/1阶段：开源框架源码剖析/01模块：自定义持久层框架设计及MyBatis源码分析)
- **🚀Java超神之路：**[**【🍔Java全生态技术学习笔记，一起超神吧🍔】**](https://github.com/EayonLee/JavaGod)


## 目录

[TOC]



## 概述

​	市面上有许多的持久层框架，如：``Mybatis``、``SpringData JPA``......。他们都是基于JDBC的封装，那么我们想要去自定义持久层框架就得了解JDBC，相信大家都了解过JDBC，知道使用JDBC进行持久化操作非常的复杂，那么我们下面就来分析JDBC的代码缺陷，这样才能更好的自定义持久层框架。



## 一.  分析JDBC操作问题

以下是通过JDBC连接数据库进行查询操作的示例代码，我们来分析，这样进行数据查询会有哪些问题。

![](https://cdn.jsdelivr.net/gh/EayonLee/IMG-Cloud@master/data/jdbc代码.png)

### 1.1 一张图解析传统JDBC代码的缺陷

![](https://cdn.jsdelivr.net/gh/EayonLee/IMG-Cloud@master/data/jdbc问题分析.png)

**原始JDBC开发存在的问题如下：**

1. 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。
2. SQL语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，SQL变动需要改变Java代码。
3. 使用``preparedStatement``向占有位符号传参数存在硬编码，因为SQL语句的``where``条件不一定，可能多也可能少，修改SQL还要修改代码，系统不易维护。
4. 对结果集解析存在硬编码(查询列名)，SQL变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。

### 1.2  原始JDBC开发存在问题解决方案

![img](https://cdn.jsdelivr.net/gh/EayonLee/IMG-Cloud@master/data/javagod成神之路.png)



## 二. 自定义持久层框架设计思路

> 以下所有使用到的文件名、类名或变量名等都是我自定义的，如果和MyBatis雷同纯属巧合（哈哈哈），大家也可以随便定义。

### 2.1 客户端

**啥是客户端？**：可理解为是一个使用我们自定义持久层框架的项目。

​	按照我们原来使用Mybatis的经验，我们知道客户端需要提供两个核心配置信息：数据库配置信息、SQL配置信息。

​	而且根据上面我们分析JDBC的缺陷时，数据库配置信息和SQL配置信息都是写死在代码中的，那么我们自定义的时候肯定不能写死在代码里，我们需要写在配置文件中。

#### （1）提供配置文件供持久层框架读取：

* **sqlMapConfig.xml**：存放数据库配置信息

* **mapper.xml**：SQL配置信息：SQL语句、参数类型、返回值类型



### 2.2 自定义持久层框架端

**啥是自定义持久层框架端？**：其实就是对JDBC封装的一个工厂，供客户端使用。

​	我们知道自定义持久层框架其实本质是对JDBC代码进行封装，因此我们需要做以下一些工作：

#### （1）读取客户端提供的配置文件：

* 创建``Resources``类，并定义``getResourcesAsStream(String path)``方法将配置文件读取成字节流存储与内存中并返回。

  **思考**：我们现在可以用``getResourceAsStream()``方法去加载配置文件，但是客户端有两个配置文件难道我们就要去加载两次吗？

其实我们可以将``*mapper.xml``配置文件的全路径存放于``sqlMapConfig.xml``中，这样我们只需要加载一次``sqlMapConfig.xml就可以全部获取了。

#### （2）创建两个容器对象：

​		从第一步来看，我们只是将配置文件读取到了内存中，而内存中的数据我们是不是不方便操作？所以我们要基于Java面向对象的思想，将这两个配置文件解	析为	两个Java Bean：``Configuration`` 、``MappedStatement``

* **Configuration（核心配置类）:** 存放数据库基本信息，也就是客户端提供的``sqlMapConfig.xml``配置文件的内容

* **MappedStatement（映射配置类）：**存放SQL语句、参数类型、返回值类型，也就是存放``*mapper.xml``配置文件的内容

#### （3）解析配置文件：

* 创建``XMLConfigBuilder``类并定义``parseConfig(InputStream is)``方法，该方法使用``dom4j``将``sqlMapConfig.xml``在内存中的字节流封装到``Configuration``配置实体并返回。

* 创建``XMLMapperBuilder``类并定义``parse(InputStream is)``方法，该方法使用``dom4j``将``*mapper.xml``在内存中的字节流封装到``MappedStatement``配置实体，并将该实体赋值给``Configuration``中的属性。

- 创建一个构建者类SqlSessionFactoryBuilder，类中有个方法：build(InputStream is)，那build中的参数也就是内存中客户端提供的sqlMapConfig.xml文件流。SqlSessionFactoryBuilder会通过配置文件创建一个SqlSessionFactory工厂，通过session工厂生产session。

#### （4）创建SqlSessionFactory接口及实现类DefaultSqlSessionFactory：

- 创建``SqlSessionFactory``接口及实现类``DefaultSqlSessionFactory``Session工厂，并提供一个openSession() 方法来生产sqlSession（会话对象），那其实我们对数据的增删改查方法都封装在sqlSession中。

#### （5）创建SqlSession接口及实现类DefaultSqlSession：

​	``SqlSession``主要封装了一些对数据库CRUD（增删改查）操作的方法

- 提供``selectList()``方法：查询所有数据
- 提供``selectOne()``：查询单个
- 提供``update()``：修改
- 提供``delete()``：删除

#### （6）创建Executor接口及实现类SimpleExecutor：

- 创建Executor接口及实现类SimpleExecutor并提供``query(Configuration c, MappedStatement m, Object...param)``方法，用于执行封装的jdbc代码

  **解释：**本步操作其实就是将jdbc的增删改查方法封装到``Executor``接口及实现类``SimpleExcutor``来做进一步的封装，这个qeury方法其实就是对jdbc原始查询操作的封装。参数分别为：核心配置文件、*mapper映射文件、查询参数。那么比如使用``DefaultSqlSession``中``selectList()``方法调用的也就是``SimpleExcutor``中封装的``query()``方法。



















